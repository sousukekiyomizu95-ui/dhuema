<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>カードゲーム プレイマット</title>
    <script src="https://cdn.tailwindcss.com/"></script>
    <style>
        body { font-family: 'Inter', sans-serif, 'Noto Sans JP', sans-serif; user-select: none; overflow-x: hidden; }
        .zone { border: 2px dashed #9ca3af; border-radius: 0.75rem; padding: 0.75rem; min-height: 140px; background-color: rgba(255, 255, 255, 0.05); display: flex; flex-wrap: wrap; gap: 0.5rem; align-content: flex-start; }
        .zone-title { position: absolute; top: -12px; left: 12px; background-color: #1f2937; padding: 0 8px; color: #9ca3af; font-weight: bold; font-size: 0.9rem; display: flex; align-items: center; }
        .card { position: relative; width: 80px; height: 112px; border: 1px solid #4b5563; border-radius: 0.5rem; background-color: #374151; color: white; padding: 4px; font-size: 0.75rem; cursor: grab; display: flex; justify-content: center; align-items: center; text-align: center; transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.5); word-break: break-all; flex-shrink: 0; }
        .card:active { cursor: grabbing; }
        .card.dragging { opacity: 0.5; box-shadow: 0 8px 16px rgba(0,0,0,0.5); }
        .card.facedown { background-color: #4a1d96 !important; background-image: repeating-radial-gradient( circle at 0 0, transparent 0, #4a1d96 10px ), repeating-linear-gradient( #5825a8, #4a1d96 ) !important; color: transparent !important; }
        .card.gr-back { background-color: #14532d !important; background-image: repeating-radial-gradient( circle at 0 0, transparent 0, #14532d 10px ), repeating-linear-gradient( #166534, #14532d ) !important; color: transparent !important; }
        .card.tapped { transform: rotate(90deg); }
        .card.bg-red { background-color: #ef4444; }
        .card.bg-blue { background-color: #3b82f6; }
        .card.bg-green { background-color: #22c55e; }
        .card.bg-yellow { background-color: #eab308; color: #1f2937; }
        .card.bg-black { background-color: #1f2937; }
        .card.bg-white { background-color: #f9fafb; color: #1f2937; border-color: #6b7280; }
        .card.selected { border-color: #60a5fa; border-width: 2px; box-shadow: 0 0 10px #60a5fa; }
        .card.poised { border-color: #0ea5e9; border-width: 3px; box-shadow: 0 0 15px #0ea5e9; transform: scale(1.05); }
        .drag-over { background-color: rgba(59, 130, 246, 0.2); border-color: #3b82f6; }
        .context-menu { position: absolute; display: none; z-index: 2500; background-color: #2d3748; border: 1px solid #4a5568; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); padding: 0.5rem; min-width: 180px; }
        .context-menu button { display: block; width: 100%; padding: 0.5rem 1rem; text-align: left; background: none; border: none; color: white; border-radius: 0.25rem; cursor: pointer; }
        .context-menu button:hover { background-color: #4a5568; }
        .context-menu hr { border-color: #4a5568; margin: 0.5rem 0; }
        .card-badge { position: absolute; color: white; font-size: 0.7rem; font-weight: bold; width: 20px; height: 20px; border-radius: 50%; display: flex; justify-content: center; align-items: center; border: 1px solid rgba(255,255,255,0.5); }
        .stack-count { bottom: 2px; right: 4px; background-color: rgba(239, 68, 68, 0.9); }
        .seal-count { bottom: 2px; left: 4px; background-color: rgba(59, 130, 246, 0.9); }
        .selection-order-badge { top: 2px; left: 4px; background-color: rgba(59, 130, 246, 0.9); }
        .stack-count:empty, .selection-order-badge:empty, .seal-count:empty { display: none; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; justify-content: center; align-items: center; z-index: 2000; }
        .modal-content { background-color: #1f2937; padding: 1.5rem; border-radius: 0.75rem; max-width: 90%; max-height: 80%; overflow-y: auto; color: white; }
    </style>
</head>
<body class="bg-gray-800 text-white p-4">

    <!-- Deck Setup Area -->
    <div id="setup-area" class="mb-4 p-4 bg-gray-900 rounded-lg shadow-lg">
        <h2 class="text-xl font-bold mb-4">デッキ作成</h2>
        <div class="mb-4 p-3 border border-gray-700 rounded-lg">
            <label class="block text-sm font-medium text-gray-300 mb-2">カード名を手動で追加</label>
            <div id="normal-card-inputs">
                <input type="text" id="manual-card-name" class="w-full bg-gray-700 text-white border border-gray-600 rounded-md p-2" placeholder="カード名を入力">
            </div>
            <div id="dragheart-card-inputs" class="hidden space-y-2">
                <input type="text" id="dragheart-name1" class="w-full bg-gray-700 text-white border border-gray-600 rounded-md p-2" placeholder="表：クリーチャー名">
                <input type="text" id="dragheart-name2" class="w-full bg-gray-700 text-white border border-gray-600 rounded-md p-2" placeholder="裏：ウェポン名">
            </div>
            <div class="flex items-center justify-between mt-2">
                 <input type="number" id="manual-card-quantity" class="bg-gray-700 text-white border border-gray-600 rounded-md p-2 w-20 text-center" value="1" min="1" max="40">
                <label class="flex items-center gap-2 cursor-pointer text-sm text-gray-300"><input type="checkbox" id="is-dragheart-checkbox" class="form-checkbox h-4 w-4 rounded bg-gray-700 border-gray-600 text-cyan-500 focus:ring-cyan-600"> ドラグハート</label>
            </div>
             <div id="deck-type-selector" class="flex gap-x-4 gap-y-2 items-center flex-wrap my-3">
                <span class="text-sm text-gray-300">種類:</span>
                <label class="flex items-center gap-1 cursor-pointer"><input type="radio" name="deckType" value="main" checked class="form-radio h-4 w-4 bg-gray-700 border-gray-600 text-indigo-500 focus:ring-indigo-600"> メイン</label>
                <label class="flex items-center gap-1 cursor-pointer"><input type="radio" name="deckType" value="extra" class="form-radio h-4 w-4 bg-gray-700 border-gray-600 text-indigo-500 focus:ring-indigo-600"> 超次元</label>
                <label class="flex items-center gap-1 cursor-pointer"><input type="radio" name="deckType" value="gr" class="form-radio h-4 w-4 bg-gray-700 border-gray-600 text-indigo-500 focus:ring-indigo-600"> GR</label>
            </div>
            <div id="color-selector" class="flex gap-x-4 gap-y-2 items-center flex-wrap mb-3">
                <span class="text-sm text-gray-300">色:</span>
                <label class="flex items-center gap-1 cursor-pointer"><input type="checkbox" name="cardColor" value="red" class="form-checkbox h-4 w-4 rounded bg-gray-700 border-gray-600 text-red-500 focus:ring-red-600"> 赤</label>
                <label class="flex items-center gap-1 cursor-pointer"><input type="checkbox" name="cardColor" value="blue" class="form-checkbox h-4 w-4 rounded bg-gray-700 border-gray-600 text-blue-500 focus:ring-blue-600"> 青</label>
                <label class="flex items-center gap-1 cursor-pointer"><input type="checkbox" name="cardColor" value="green" class="form-checkbox h-4 w-4 rounded bg-gray-700 border-gray-600 text-green-500 focus:ring-green-600"> 緑</label>
                <label class="flex items-center gap-1 cursor-pointer"><input type="checkbox" name="cardColor" value="yellow" class="form-checkbox h-4 w-4 rounded bg-gray-700 border-gray-600 text-yellow-500 focus:ring-yellow-600"> 黄</label>
                <label class="flex items-center gap-1 cursor-pointer"><input type="checkbox" name="cardColor" value="black" class="form-checkbox h-4 w-4 rounded bg-gray-700 border-gray-600 text-gray-500 focus:ring-gray-600"> 黒</label>
                <label class="flex items-center gap-1 cursor-pointer"><input type="checkbox" name="cardColor" value="white" class="form-checkbox h-4 w-4 rounded bg-gray-700 border-gray-600 text-gray-300 focus:ring-gray-400"> 白</label>
            </div>
            <button id="add-card-button" class="bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-lg transition w-full">追加</button>
        </div>
        <p class="text-gray-400 mb-2">カードリスト (1行に1枚、書式: [種類]カード名|色...)</p>
        <textarea id="card-list" class="w-full h-40 bg-gray-700 text-white border border-gray-600 rounded-md p-2"></textarea>
        <div class="flex items-center justify-between mt-4">
            <div id="card-count-details" class="text-gray-400 text-sm">
                <p>メイン: <span id="main-deck-count">0</span>枚</p>
                <p>超次元: <span id="extra-deck-count">0</span>枚</p>
                <p>GR: <span id="gr-deck-count">0</span>枚</p>
            </div>
            <button id="start-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-6 rounded-lg transition">スタート</button>
        </div>
    </div>

    <!-- Playmat Area -->
    <div id="playmat-area" class="hidden relative">
        <button id="reset-button" class="absolute top-0 right-0 bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded-lg text-sm z-10 m-2">リセット</button>
        <div class="flex flex-col gap-4">
            <div class="relative"><div id="battle-zone" class="zone min-h-[200px]"></div><span class="zone-title">バトルゾーン</span></div>
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div class="md:col-span-1 relative"><div id="deck-zone" class="zone"></div><span class="zone-title">山札 (<span id="deck-count">0</span>)</span></div>
                <div class="md:col-span-3 relative"><div id="shield-zone" class="zone"></div><span class="zone-title">シールドゾーン</span></div>
            </div>
            <div class="relative"><div id="hand-zone" class="zone"></div><span class="zone-title">手札</span></div>
            <div class="relative"><div id="mana-zone" class="zone"></div><span class="zone-title">マナゾーン<button id="untap-all-mana-button" class="ml-2 bg-blue-600 hover:bg-blue-700 text-white text-xs px-2 py-0.5 rounded-md transition shadow-sm">全アンタップ</button></span></div>
            <div class="relative"><div id="graveyard-zone" class="zone"></div><span class="zone-title">墓地</span></div>
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div class="md:col-span-1 relative"><div id="gr-zone" class="zone"></div><span class="zone-title">GRゾーン (<span id="gr-deck-count-display">0</span>)</span></div>
                <div class="md:col-span-3 relative"><div id="extra-deck-zone" class="zone"></div><span class="zone-title">超次元ゾーン</span></div>
            </div>
        </div>
    </div>

    <!-- Context Menus -->
    <div id="move-menu" class="context-menu">
        <button data-action="seal">封印</button>
        <button data-action="return-gr" class="hidden">GRゾーンに戻す</button>
        <button data-action="kakumei-change" class="hidden">革命チェンジ</button>
        <hr class="action-hr hidden">
        <button data-zone="battle-zone">バトルゾーンへ</button>
        <button data-zone="mana-zone">マナゾーンへ</button>
        <button data-zone="graveyard-zone">墓地へ</button>
        <button data-zone="hand-zone">手札へ</button>
        <button data-zone="shield-zone">シールドゾーンへ</button>
        <button data-zone="extra-deck-zone">超次元ゾーンへ</button>
        <hr>
        <button data-zone="deck-top">山札の一番上へ</button>
        <button data-zone="deck-bottom">山札の一番下へ</button>
        <hr>
        <button data-action="flip">表向き/裏向きにする</button>
        <hr class="dragheart-hr hidden">
        <button data-action="ryukai" class="hidden">龍解</button>
        <button data-action="kaijo" class="hidden">解除</button>
        <hr class="dragheart-hr hidden">
        <button data-action="stack-over">カードの上に置く</button>
        <button data-action="stack-under">カードの下に置く</button>
        <button data-action="stack-on-shield">シールドに重ねる</button>
        <button data-action="view-stack" class="hidden">下のカードを見る</button>
        <hr>
        <button data-action="cancel">キャンセル</button>
    </div>

    <div id="seal-menu" class="context-menu">
        <button data-action="view-seals">封印の枚数を見る</button>
        <button data-action="remove-seals">封印を剥がす</button>
        <hr>
        <button data-action="cancel">キャンセル</button>
    </div>
    
    <div id="deck-menu" class="context-menu">
        <button data-action="draw-cards">ドロー</button>
        <hr>
        <button data-action="view-all">山札を見る</button>
        <button data-action="reveal-top">山札の上を見る</button>
        <button data-action="view-bottom">山札の下を見る</button>
        <hr>
        <button data-action="yobunion">ヨビニオン</button>
        <hr>
        <button data-action="mill-top">墓地に置く</button>
        <button data-action="mana-top">マナゾーンに置く</button>
        <button data-action="shield-top">シールドゾーンに置く</button>
        <hr>
        <button data-action="shuffle">シャッフルする</button>
        <hr>
        <button data-action="cancel">キャンセル</button>
    </div>

    <!-- Modals -->
    <div id="stack-view-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-lg font-bold mb-4">重ねられているカード</h3>
            <div id="stacked-cards-list" class="space-y-2"></div>
            <button id="close-stack-view" class="mt-4 bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg">閉じる</button>
        </div>
    </div>
    <div id="reveal-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 id="reveal-modal-title" class="text-lg font-bold">山札</h3>
                <button id="return-all-to-bottom-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-1 px-3 rounded-lg text-sm hidden">全て山札の下へ戻す</button>
            </div>
            <div id="revealed-cards-list" class="flex flex-wrap gap-2 p-2 bg-gray-800 rounded-lg min-h-[120px]"></div>
            <button id="close-reveal-modal" class="mt-4 bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg">閉じる</button>
        </div>
    </div>
    <div id="yobunion-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-lg font-bold mb-4">ヨビニオン</h3>
            <div id="yobunion-cards-list" class="flex flex-wrap gap-2 p-2 bg-gray-800 rounded-lg min-h-[120px]"></div>
            <div class="mt-4 flex justify-end gap-2">
                 <button id="one-more-yobunion-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">もう一枚</button>
                <button id="finish-yobunion-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg">終了</button>
            </div>
        </div>
    </div>
     <div id="number-input-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 id="number-input-title" class="text-lg font-bold mb-4">枚数を入力</h3>
            <input type="number" id="number-input-field" class="w-full bg-gray-700 text-white border border-gray-600 rounded-md p-2 text-center" value="1" min="1">
            <div class="mt-4 flex justify-end gap-2">
                <button id="cancel-number-input" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg">キャンセル</button>
                <button id="confirm-number-input" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">決定</button>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const setupArea = document.getElementById('setup-area');
        const playmatArea = document.getElementById('playmat-area');
        const manualCardNameInput = document.getElementById('manual-card-name');
        const manualCardQuantityInput = document.getElementById('manual-card-quantity');
        const addCardButton = document.getElementById('add-card-button');
        const cardListInput = document.getElementById('card-list');
        const startButton = document.getElementById('start-button');
        const resetButton = document.getElementById('reset-button');
        const deckCountDisplay = document.getElementById('deck-count');
        const grDeckCountDisplay = document.getElementById('gr-deck-count-display');
        const zones = document.querySelectorAll('.zone');
        const deckZone = document.getElementById('deck-zone');
        const grZoneEl = document.getElementById('gr-zone');
        const shieldZoneEl = document.getElementById('shield-zone');
        const moveMenu = document.getElementById('move-menu');
        const sealMenu = document.getElementById('seal-menu');
        const deckMenu = document.getElementById('deck-menu');
        // Dragheart inputs
        const isDragheartCheckbox = document.getElementById('is-dragheart-checkbox');
        const normalCardInputs = document.getElementById('normal-card-inputs');
        const dragheartCardInputs = document.getElementById('dragheart-card-inputs');
        const dragheartName1Input = document.getElementById('dragheart-name1');
        const dragheartName2Input = document.getElementById('dragheart-name2');
        const deckTypeSelector = document.getElementById('deck-type-selector');
        // Modals
        const stackViewModal = document.getElementById('stack-view-modal');
        const stackedCardsList = document.getElementById('stacked-cards-list');
        const revealModal = document.getElementById('reveal-modal');
        const revealedCardsList = document.getElementById('revealed-cards-list');
        const revealModalTitle = document.getElementById('reveal-modal-title');
        const closeRevealModalBtn = document.getElementById('close-reveal-modal');
        const yobunionModal = document.getElementById('yobunion-modal');
        const yobunionCardsList = document.getElementById('yobunion-cards-list');
        const finishYobunionBtn = document.getElementById('finish-yobunion-btn');
        const oneMoreYobunionBtn = document.getElementById('one-more-yobunion-btn');
        const numberInputModal = document.getElementById('number-input-modal');
        const numberInputField = document.getElementById('number-input-field');
        const numberInputTitle = document.getElementById('number-input-title');
        const confirmNumberInputBtn = document.getElementById('confirm-number-input');
        const cancelNumberInputBtn = document.getElementById('cancel-number-input');
        const returnAllToBottomBtn = document.getElementById('return-all-to-bottom-btn');

        let deck = [];
        let grDeck = [];
        let revealedCards = [];
        let revealSource = null; // 'top', 'bottom', 'all'
        let yobunionCards = [];
        let selectionOrder = [];
        let cardIdCounter = 0;
        let poisedCard = { card: null, mode: null, type: null };

        // --- Event Listeners ---
        cardListInput.addEventListener('input', updateCardCount);
        addCardButton.addEventListener('click', addCardToListManually);
        manualCardNameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); addCardToListManually(); }
        });
        isDragheartCheckbox.addEventListener('change', () => {
            normalCardInputs.classList.toggle('hidden');
            dragheartCardInputs.classList.toggle('hidden');
            if (isDragheartCheckbox.checked) {
                deckTypeSelector.querySelector('input[value="extra"]').checked = true;
                deckTypeSelector.style.display = 'none';
            } else {
                 deckTypeSelector.style.display = 'flex';
            }
        });
        startButton.addEventListener('click', startGame);
        resetButton.addEventListener('click', resetGame);


        // --- Card Creation and Management ---
        function updateCardCount() {
            const lines = cardListInput.value.split('\n').filter(line => line.trim() !== '');
            let mainCount = 0, extraCount = 0, grCount = 0;
            lines.forEach(line => {
                const cleanLine = line.trim();
                if (cleanLine.startsWith('[E]') || cleanLine.startsWith('[D]')) extraCount++;
                else if (cleanLine.startsWith('[G]')) grCount++;
                else mainCount++;
            });
            document.getElementById('main-deck-count').textContent = mainCount;
            document.getElementById('extra-deck-count').textContent = extraCount;
            document.getElementById('gr-deck-count').textContent = grCount;
        }

        function addCardToListManually() {
            let cardName;
            let prefix = '';
            const quantity = parseInt(manualCardQuantityInput.value, 10) || 1;
            const selectedColors = Array.from(document.querySelectorAll('input[name="cardColor"]:checked')).map(cb => cb.value);
            const colorString = selectedColors.join(',');

            if(isDragheartCheckbox.checked) {
                const name1 = dragheartName1Input.value.trim();
                const name2 = dragheartName2Input.value.trim();
                if(!name1 || !name2) return;
                cardName = `${name1}//${name2}`;
                prefix = '[D]';
            } else {
                cardName = manualCardNameInput.value.trim();
                if(!cardName) return;
                const deckType = document.querySelector('input[name="deckType"]:checked').value;
                if (deckType === 'extra') prefix = '[E]';
                if (deckType === 'gr') prefix = '[G]';
            }
            
            const lineToAdd = `${prefix}${cardName}|${colorString}`;
            const linesToAdd = Array(quantity).fill(lineToAdd);
            const currentList = cardListInput.value.trim();
            cardListInput.value = (currentList ? currentList + '\n' : '') + linesToAdd.join('\n');
            
            updateCardCount();
            manualCardNameInput.value = '';
            dragheartName1Input.value = '';
            dragheartName2Input.value = '';
            manualCardQuantityInput.value = '1';
            manualCardNameInput.focus();
            cardListInput.scrollTop = cardListInput.scrollHeight;
        }
        
        function resetGame() {
            playmatArea.classList.add('hidden');
            setupArea.style.display = 'block';
            
            deck = [];
            grDeck = [];
            revealedCards = [];
            yobunionCards = [];
            selectionOrder = [];
            cancelPoisedCard();

            zones.forEach(zone => {
                zone.innerHTML = '';
            });
            
            updateDeckDisplay();
            updateGRDeckDisplay();
        }

        function startGame() {
            const cardLines = cardListInput.value.split('\n').filter(line => line.trim() !== '');
            if (cardLines.length === 0) { alert('カードが1枚もありません。'); return; }
            setupArea.style.display = 'none';
            playmatArea.classList.remove('hidden');
            zones.forEach(zone => zone.innerHTML = '');

            let mainDeck = [], extraDeckCards = [];
            grDeck = [];
            cardLines.forEach(line => {
                let name = line, type = 'main', isDragheart = false, name1 = null, name2 = null;
                if (line.startsWith('[E]')) { type = 'extra'; name = line.substring(3); }
                if (line.startsWith('[G]')) { type = 'gr'; name = line.substring(3); }
                if (line.startsWith('[D]')) { 
                    type = 'extra'; 
                    name = line.substring(3);
                    isDragheart = true;
                    const nameParts = name.split('|')[0].split('//');
                    name1 = nameParts[0];
                    name2 = nameParts[1];
                    name = name1 + '|' + (name.split('|')[1] || '');
                }
                
                const parts = name.split('|');
                const cardData = { name: parts[0], name1: name1, name2: name2, colors: parts[1] ? parts[1].split(',').filter(Boolean) : [], isDragheart: isDragheart, isFlipped: false, type: type };

                if (type === 'extra') extraDeckCards.push(cardData);
                else if (type === 'gr') grDeck.push(cardData);
                else mainDeck.push(cardData);
            });

            deck = shuffleArray(mainDeck);
            cardIdCounter = 0;
            const shieldZone = document.getElementById('shield-zone');
            for (let i = 0; i < 5 && deck.length > 0; i++) shieldZone.appendChild(createCard(deck.pop(), true));
            const handZone = document.getElementById('hand-zone');
            for (let i = 0; i < 5 && deck.length > 0; i++) handZone.appendChild(createCard(deck.pop(), false));
            
            const extraDeckZone = document.getElementById('extra-deck-zone');
            extraDeckCards.forEach(cardData => extraDeckZone.appendChild(createCard(cardData, cardData.isDragheart ? false : true)));
            
            grDeck = shuffleArray(grDeck);
            updateDeckDisplay();
            updateGRDeckDisplay();
        }

        function createCard(cardData, isFaceDown = false, isRevealed = false) {
            const card = document.createElement('div');
            card.id = `card-${cardIdCounter++}`;
            card.className = 'card';
            card.draggable = true;
            card.dataset.name = cardData.name;
            card.dataset.colors = cardData.colors.join(',');
            card.dataset.stackedCards = '[]';
            card.dataset.seals = '[]';
            card.dataset.type = cardData.type || 'main';

            if(cardData.isDragheart) {
                card.dataset.isDragheart = 'true';
                card.dataset.name1 = cardData.name1;
                card.dataset.name2 = cardData.name2;
                card.dataset.isFlipped = cardData.isFlipped ? 'true' : 'false';
            }
            
            const nameSpan = document.createElement('span');
            nameSpan.className = 'card-name';
            card.appendChild(nameSpan);

            const stackCount = document.createElement('div');
            stackCount.className = 'stack-count card-badge';
            card.appendChild(stackCount);
            
            const sealCount = document.createElement('div');
            sealCount.className = 'seal-count card-badge';
            card.appendChild(sealCount);

            if (isRevealed) {
                const selectionBadge = document.createElement('div');
                selectionBadge.className = 'selection-order-badge card-badge';
                card.appendChild(selectionBadge);
            }

            applyCardAppearance(card, isFaceDown);
            addCardEventListeners(card);
            return card;
        }

        function applyCardAppearance(card, isFaceDown) {
            const nameSpan = card.querySelector('.card-name');
            if (!nameSpan) return;
            card.style.background = '';
            ['red', 'blue', 'green', 'yellow', 'black', 'white'].forEach(c => card.classList.remove(`bg-${c}`));
            if (isFaceDown) {
                card.classList.add('facedown');
                nameSpan.textContent = '';
            } else {
                card.classList.remove('facedown');
                nameSpan.textContent = card.dataset.isFlipped === 'true' ? card.dataset.name2 : card.dataset.name1 || card.dataset.name;
                const colors = card.dataset.colors ? card.dataset.colors.split(',').filter(Boolean) : [];
                if (colors.length === 1) {
                    card.classList.add(`bg-${colors[0]}`);
                } else if (colors.length > 1) {
                    const colorHex = { red: '#ef4444', blue: '#3b82f6', green: '#22c55e', yellow: '#eab308', black: '#1f2937', white: '#f9fafb' };
                    const colorStops = colors.map((color, index, arr) => `${colorHex[color]} ${index * 100 / arr.length}%, ${colorHex[color]} ${(index + 1) * 100 / arr.length}%`).join(', ');
                    card.style.background = `linear-gradient(to right, ${colorStops})`;
                    card.style.color = (colors.includes('yellow') || colors.includes('white')) ? '#1f2937' : 'white';
                }
            }
        }
        
        function addCardEventListeners(card) {
            card.addEventListener('dragstart', (e) => { e.dataTransfer.setData('text/plain', e.target.id); setTimeout(() => card.classList.add('dragging'), 0); });
            card.addEventListener('dragend', () => card.classList.remove('dragging'));

            card.addEventListener('click', (e) => {
                if (poisedCard.card) return handlePoisedCardClick(card);
                const parentZone = card.parentElement;
                if (card.dataset.name === 'Deck') {
                    showDeckMenu(e.clientX, e.clientY);
                } else if (card.dataset.name === 'GR Deck') {
                    grSummon();
                } else if (parentZone && parentZone.id === 'shield-zone') {
                    applyCardAppearance(card, false);
                } else if (parentZone && (parentZone.id === 'battle-zone' || parentZone.id === 'mana-zone')) {
                    card.classList.toggle('tapped');
                }
            });

            card.addEventListener('dblclick', (e) => {
                if(poisedCard.card && poisedCard.card.id === card.id) return cancelPoisedCard();
                if(poisedCard.card) return;
                 if (card.dataset.name === 'Deck') {
                    if (deck.length > 0) document.getElementById('hand-zone').appendChild(createCard(deck.pop(), false));
                    else alert('山札がありません。');
                    updateDeckDisplay();
                } else {
                    const seals = JSON.parse(card.dataset.seals || '[]');
                    if (seals.length > 0) {
                        showSealMenu(card, e.clientX, e.clientY);
                    } else {
                        showMoveMenu(card, e.clientX, e.clientY);
                    }
                }
            });
        }
        
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; }
            return array;
        }

        // --- Zone Placement Rules ---
        function applyManaTap(card) {
            const colors = card.dataset.colors.split(',').filter(Boolean);
            if(card.classList.contains('facedown')) {
                card.classList.remove('tapped');
            } else {
                if (colors.length >= 2) card.classList.add('tapped');
                else card.classList.remove('tapped');
            }
        }
        
        function applyShieldPlacement(card, isInitial = false) {
            if (isInitial) {
                applyCardAppearance(card, true);
                card.classList.remove('tapped');
            } else {
                applyCardAppearance(card, true);
                card.classList.add('tapped');
            }
        }

        // --- Zone and Playmat Interaction ---
        zones.forEach(zone => {
            zone.addEventListener('dragover', (e) => { e.preventDefault(); zone.classList.add('drag-over'); });
            zone.addEventListener('dragleave', () => zone.classList.remove('drag-over'));
            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                zone.classList.remove('drag-over');
                const id = e.dataTransfer.getData('text/plain');
                const draggable = document.getElementById(id);
                if (draggable) { 
                    if (zone.id !== 'shield-zone') unstackCard(draggable, zone);
                    if (zone.id === 'extra-deck-zone' && draggable.dataset.isDragheart === 'true') {
                        revertDragheart(draggable);
                    }
                    zone.appendChild(draggable); 
                    if (zone.id === 'mana-zone') applyManaTap(draggable);
                    else if (zone.id === 'shield-zone') applyShieldPlacement(draggable, false);
                    else if (zone.id === 'hand-zone') draggable.classList.remove('tapped');
                }
            });
        });
        
        function updateDeckDisplay() {
            deckZone.innerHTML = '';
            deckCountDisplay.textContent = deck.length;
            if (deck.length > 0) {
                const deckCard = createCard({name: 'Deck', colors: []}, true);
                deckCard.draggable = false;
                deckCard.style.cursor = 'pointer';
                deckZone.appendChild(deckCard);
            }
        }
        
        function updateGRDeckDisplay() {
            grZoneEl.innerHTML = '';
            grDeckCountDisplay.textContent = grDeck.length;
            if (grDeck.length > 0) {
                const grDeckCard = createCard({name: 'GR Deck', colors: [], type: 'gr'}, true);
                grDeckCard.classList.remove('facedown');
                grDeckCard.classList.add('gr-back');
                grDeckCard.draggable = false;
                grDeckCard.style.cursor = 'pointer';
                grZoneEl.appendChild(grDeckCard);
            }
        }
        
        function grSummon() {
            if (grDeck.length === 0) { alert('GRゾーンにカードがありません。'); return; }
            const cardData = grDeck.pop();
            const newCard = createCard(cardData, false);
            document.getElementById('battle-zone').appendChild(newCard);
            updateGRDeckDisplay();
        }
        
        document.getElementById('untap-all-mana-button').addEventListener('click', () => {
            document.querySelectorAll('#mana-zone .card.tapped').forEach(card => card.classList.remove('tapped'));
        });

        // --- Stacking & Sealing Logic ---
        function setPoisedCard(type, sourceCard, stackMode = null) {
            cancelPoisedCard(); // Cancel any previous selection
            poisedCard = { card: sourceCard, mode: stackMode, type: type };
            sourceCard.classList.add('poised');
        }

        function cancelPoisedCard() {
            if(poisedCard.card) {
                poisedCard.card.classList.remove('poised');
            }
            poisedCard = { card: null, mode: null, type: null };
        }

        function handlePoisedCardClick(targetCard) {
            const { card: sourceCard, mode, type } = poisedCard;
            if (!sourceCard) return;

            if (
                (type === 'stack-battle' && targetCard.parentElement.id === 'battle-zone') ||
                (type === 'stack-shield' && targetCard.parentElement.id === 'shield-zone') ||
                (type === 'kakumei-change' && targetCard.parentElement.id === 'battle-zone')
            ) {
                const sourceData = { name: sourceCard.dataset.name, name1: sourceCard.dataset.name1, name2: sourceCard.dataset.name2, isDragheart: sourceCard.dataset.isDragheart === 'true', colors: sourceCard.dataset.colors.split(','), stackedCards: JSON.parse(sourceCard.dataset.stackedCards) };
                const targetData = { name: targetCard.dataset.name, name1: targetCard.dataset.name1, name2: targetCard.dataset.name2, isDragheart: targetCard.dataset.isDragheart === 'true', colors: targetCard.dataset.colors.split(','), stackedCards: JSON.parse(targetCard.dataset.stackedCards) };
                
                if (type === 'kakumei-change') {
                    const handZone = sourceCard.parentElement;
                    const battleZone = targetCard.parentElement;
                    handZone.appendChild(targetCard);
                    battleZone.appendChild(sourceCard);
                    targetCard.classList.remove('tapped');
                    sourceCard.classList.remove('tapped');
                }
                else if (type === 'stack-shield') {
                    const newStack = [targetData, ...targetData.stackedCards, ...sourceData.stackedCards];
                    targetCard.dataset.stackedCards = JSON.stringify(newStack);
                    applyCardAppearance(targetCard, true);
                } else if (mode === 'stack-over') {
                    const newStack = [targetData, ...targetData.stackedCards, ...sourceData.stackedCards];
                    targetCard.dataset.name = sourceData.name;
                     if(sourceData.isDragheart) {
                        targetCard.dataset.isDragheart = 'true';
                        targetCard.dataset.name1 = sourceData.name1;
                        targetCard.dataset.name2 = sourceData.name2;
                        targetCard.dataset.isFlipped = 'false';
                    } else {
                        delete targetCard.dataset.isDragheart; delete targetCard.dataset.name1; delete targetCard.dataset.name2; delete targetCard.dataset.isFlipped;
                    }
                    targetCard.dataset.colors = sourceData.colors.join(',');
                    targetCard.dataset.stackedCards = JSON.stringify(newStack);
                    applyCardAppearance(targetCard, false);
                } else if (mode === 'stack-under') {
                    targetCard.dataset.stackedCards = JSON.stringify([sourceData, ...sourceData.stackedCards, ...targetData.stackedCards]);
                }
                
                if(type !== 'kakumei-change') sourceCard.remove();
                updateStackCount(targetCard);
            }
            cancelPoisedCard();
        }
        
        function updateStackCount(card) {
            const stackCountEl = card.querySelector('.stack-count');
            const stackedCards = JSON.parse(card.dataset.stackedCards);
            if (stackCountEl) stackCountEl.textContent = stackedCards.length > 0 ? stackedCards.length : '';
        }
        
        function updateSealCount(card) {
            const sealCountEl = card.querySelector('.seal-count');
            const seals = JSON.parse(card.dataset.seals);
            if (sealCountEl) sealCountEl.textContent = seals.length > 0 ? seals.length : '';
        }

        function unstackCard(card, targetZone) {
            const stackedCards = JSON.parse(card.dataset.stackedCards);
            if (stackedCards.length > 0) {
                stackedCards.forEach(cardData => {
                    const newCard = createCard(cardData, targetZone.id !== 'hand-zone' && card.classList.contains('facedown'));
                    targetZone.appendChild(newCard);
                });
                card.dataset.stackedCards = '[]';
                updateStackCount(card);
            }
        }
        
        function revertDragheart(card) {
            if(card.dataset.isDragheart === 'true') {
                card.dataset.name = card.dataset.name1;
                card.dataset.isFlipped = 'false';
                applyCardAppearance(card, false);
            }
        }
        
        // --- Context Menu Logic ---
        function showMoveMenu(card, x, y, context = {}) {
            const stackedCards = JSON.parse(card.dataset.stackedCards || '[]');
            const isDragheart = card.dataset.isDragheart === 'true';
            const isFlipped = card.dataset.isFlipped === 'true';
            const isGR = card.dataset.type === 'gr';
            const isInHand = card.parentElement.id === 'hand-zone';

            moveMenu.querySelector('[data-action="view-stack"]').style.display = stackedCards.length > 0 ? 'block' : 'none';
            moveMenu.querySelectorAll('.dragheart-hr').forEach(el => el.style.display = isDragheart ? 'block' : 'none');
            moveMenu.querySelector('[data-action="ryukai"]').style.display = isDragheart && !isFlipped ? 'block' : 'none';
            moveMenu.querySelector('[data-action="kaijo"]').style.display = isDragheart && isFlipped ? 'block' : 'none';
            moveMenu.querySelector('[data-action="return-gr"]').style.display = isGR ? 'block' : 'none';
            moveMenu.querySelector('.action-hr').style.display = (isGR || isInHand) ? 'block' : 'none';
            moveMenu.querySelector('[data-action="kakumei-change"]').style.display = isInHand ? 'block' : 'none';

            moveMenu.style.display = 'block';
            moveMenu.style.left = `${x}px`;
            moveMenu.style.top = `${y}px`;
            
            if(context.revealedIndex !== undefined) {
                moveMenu.dataset.revealedIndex = context.revealedIndex;
                moveMenu.dataset.revealedCardId = card.id;
            } else if (context.yobunionIndex !== undefined) {
                moveMenu.dataset.yobunionIndex = context.yobunionIndex;
                moveMenu.dataset.yobunionCardId = card.id;
            } else {
                 moveMenu.dataset.cardId = card.id;
            }
        }
        
        function showSealMenu(card, x, y) {
            sealMenu.style.display = 'block';
            sealMenu.style.left = `${x}px`;
            sealMenu.style.top = `${y}px`;
            sealMenu.dataset.cardId = card.id;
        }

        function hideAllMenus() {
            moveMenu.style.display = 'none';
            deckMenu.style.display = 'none';
            sealMenu.style.display = 'none';
            delete moveMenu.dataset.cardId;
            delete moveMenu.dataset.stackSourceCardId;
            delete moveMenu.dataset.stackIndex;
            delete moveMenu.dataset.revealedIndex;
            delete moveMenu.dataset.revealedCardId;
            delete moveMenu.dataset.yobunionIndex;
            delete moveMenu.dataset.yobunionCardId;
            delete sealMenu.dataset.cardId;
        }
        
        function showDeckMenu(x, y) {
            deckMenu.style.display = 'block';
            deckMenu.style.left = `${x}px`;
            deckMenu.style.top = `${y}px`;
        }
        
        moveMenu.addEventListener('click', (e) => {
            if (e.target.tagName !== 'BUTTON') return;
            let zoneId = e.target.dataset.zone;
            const action = e.target.dataset.action;

            if (moveMenu.dataset.yobunionIndex !== undefined) {
                const index = parseInt(moveMenu.dataset.yobunionIndex, 10);
                const cardData = yobunionCards[index];
                if (cardData) {
                    if (zoneId) {
                        if (zoneId.startsWith('deck-')) {
                            if (zoneId === 'deck-top') deck.push(cardData); else deck.unshift(cardData);
                            updateDeckDisplay();
                        } else {
                             const newCard = createCard(cardData, false);
                             document.getElementById(zoneId).appendChild(newCard);
                             if (zoneId === 'mana-zone') applyManaTap(newCard);
                             else if (zoneId === 'shield-zone') applyShieldPlacement(newCard, false);
                             else if (zoneId === 'hand-zone') newCard.classList.remove('tapped');
                        }
                    }
                    yobunionCards[index] = null;
                    document.getElementById(moveMenu.dataset.yobunionCardId)?.remove();
                }
                hideAllMenus(); return;
            }

            if (moveMenu.dataset.revealedIndex !== undefined) {
                const index = parseInt(moveMenu.dataset.revealedIndex, 10);
                const cardData = revealedCards[index];
                if (cardData) {
                    if (zoneId) {
                        if (zoneId.startsWith('deck-')) {
                            if (zoneId === 'deck-top') deck.push(cardData); else deck.unshift(cardData);
                            updateDeckDisplay();
                        } else {
                             const newCard = createCard(cardData, false);
                             document.getElementById(zoneId).appendChild(newCard);
                             if (zoneId === 'mana-zone') applyManaTap(newCard);
                             else if (zoneId === 'shield-zone') applyShieldPlacement(newCard, false);
                             else if (zoneId === 'hand-zone') newCard.classList.remove('tapped');
                        }
                    }
                    revealedCards[index] = null;
                    document.getElementById(moveMenu.dataset.revealedCardId)?.remove();
                }
                hideAllMenus(); return;
            }

            if (moveMenu.dataset.stackSourceCardId) {
                const topCard = document.getElementById(moveMenu.dataset.stackSourceCardId);
                if (topCard && zoneId) {
                    const stackIndex = parseInt(moveMenu.dataset.stackIndex, 10);
                    const stackedCards = JSON.parse(topCard.dataset.stackedCards);
                    const [movedCardData] = stackedCards.splice(stackIndex, 1);
                    if (movedCardData) {
                        const newCard = createCard(movedCardData, false);
                        document.getElementById(zoneId).appendChild(newCard);
                         if (zoneId === 'mana-zone') applyManaTap(newCard);
                         else if (zoneId === 'shield-zone') applyShieldPlacement(newCard, false);
                         else if (zoneId === 'hand-zone') newCard.classList.remove('tapped');
                        topCard.dataset.stackedCards = JSON.stringify(stackedCards);
                        updateStackCount(topCard);
                        refreshStackViewModal(topCard);
                    }
                }
                hideAllMenus(); return;
            }

            const card = document.getElementById(moveMenu.dataset.cardId);
            if (!card) { hideAllMenus(); return; }

            if (action === 'cancel') { cancelPoisedCard(); }
            else if (action === 'flip') { applyCardAppearance(card, !card.classList.contains('facedown')); }
            else if (action === 'ryukai') { card.dataset.isFlipped = 'true'; applyCardAppearance(card, false); }
            else if (action === 'kaijo') { card.dataset.isFlipped = 'false'; applyCardAppearance(card, false); }
            else if (action === 'stack-under') { setPoisedCard('stack-battle', card, 'stack-under'); }
            else if (action === 'stack-over') { setPoisedCard('stack-battle', card, 'stack-over'); }
            else if (action === 'stack-on-shield') { setPoisedCard('stack-shield', card); }
            else if (action === 'kakumei-change') { setPoisedCard('kakumei-change', card); }
            else if (action === 'view-stack') {
                refreshStackViewModal(card);
                stackViewModal.dataset.topCardId = card.id;
                stackViewModal.classList.remove('hidden');
            }
            else if (action === 'seal') {
                numberInputTitle.textContent = '何枚封印しますか？';
                numberInputField.value = '1';
                confirmNumberInputBtn.dataset.action = 'seal';
                confirmNumberInputBtn.dataset.targetCardId = card.id;
                numberInputModal.classList.remove('hidden');
            } else if (action === 'return-gr') {
                const cardData = { name: card.dataset.name, name1: card.dataset.name1, name2: card.dataset.name2, isDragheart: card.dataset.isDragheart === 'true', isFlipped: card.dataset.isFlipped === 'true', colors: card.dataset.colors.split(','), type: 'gr' };
                grDeck.unshift(cardData);
                card.remove();
                updateGRDeckDisplay();
            }
            else if (zoneId) {
                const cardData = { name: card.dataset.name, name1: card.dataset.name1, name2: card.dataset.name2, isDragheart: card.dataset.isDragheart === 'true', isFlipped: card.dataset.isFlipped === 'true', colors: card.dataset.colors.split(','), stackedCards: [] };
                if (zoneId.startsWith('deck-')) {
                     if (zoneId === 'deck-top') deck.push(cardData); else deck.unshift(cardData);
                     unstackCard(card, document.getElementById('graveyard-zone'));
                     card.remove(); updateDeckDisplay();
                } else {
                    const targetZone = document.getElementById(zoneId);
                    if (targetZone) { 
                        if(zoneId !== 'shield-zone') unstackCard(card, targetZone);
                        if (zoneId === 'extra-deck-zone' && card.dataset.isDragheart === 'true') {
                            revertDragheart(card);
                        }
                        targetZone.appendChild(card);
                        if (zoneId === 'mana-zone') applyManaTap(card);
                        else if (zoneId === 'shield-zone') applyShieldPlacement(card, false);
                        else if (zoneId === 'hand-zone') card.classList.remove('tapped');
                    }
                }
            }
            hideAllMenus();
        });

        sealMenu.addEventListener('click', (e) => {
            const card = document.getElementById(sealMenu.dataset.cardId);
            if (!card) { hideAllMenus(); return; }
            const action = e.target.dataset.action;
            if (action === 'view-seals') {
                const seals = JSON.parse(card.dataset.seals);
                alert(`このカードには ${seals.length} 枚の封印があります。`);
            } else if (action === 'remove-seals') {
                numberInputTitle.textContent = '何枚封印を剥がしますか？';
                numberInputField.value = '1';
                confirmNumberInputBtn.dataset.action = 'remove-seals';
                confirmNumberInputBtn.dataset.targetCardId = card.id;
                numberInputModal.classList.remove('hidden');
            }
            hideAllMenus();
        });

        deckMenu.addEventListener('click', (e) => {
            if (e.target.tagName !== 'BUTTON') return;
            const action = e.target.dataset.action;
            if (action.endsWith('-top') || action === 'draw-cards') {
                let title = '', act = '';
                if(action === 'reveal-top') { title = '何枚表向きにしますか？'; act = 'reveal'; }
                if(action === 'mill-top') { title = '何枚墓地に置きますか？'; act = 'mill'; }
                if(action === 'mana-top') { title = '何枚マナに置きますか？'; act = 'mana'; }
                if(action === 'shield-top') { title = '何枚シールドに置きますか？'; act = 'shield'; }
                if(action === 'view-bottom') { title = '山札の下を何枚見ますか？'; act = 'view-bottom'; }
                if(action === 'draw-cards') { title = '何枚ドローしますか？'; act = 'draw'; }
                
                numberInputTitle.textContent = title;
                numberInputField.value = '1';
                confirmNumberInputBtn.dataset.action = act;
                numberInputModal.classList.remove('hidden');
            }
            else if (action === 'view-all') {
                if(deck.length > 0) {
                    revealedCards = [...deck];
                    deck = [];
                    updateDeckDisplay();
                    revealSource = 'all';
                    selectionOrder = [];
                    refreshRevealModal();
                    revealModal.classList.remove('hidden');
                }
            }
            else if (action === 'yobunion') {
                if(deck.length > 0) {
                    yobunionCards = [deck.pop()];
                    updateDeckDisplay();
                    refreshYobunionModal();
                    yobunionModal.classList.remove('hidden');
                }
            }
            else if (action === 'shuffle') { 
                deck = shuffleArray(deck); 
                alert('山札をシャッフルしました。'); 
            }
            hideAllMenus();
        });
        
        // --- Modal Logic ---
        function refreshStackViewModal(topCard) {
            const stackedCards = JSON.parse(topCard.dataset.stackedCards);
            stackedCardsList.innerHTML = stackedCards.map((c, i) => `
                <div class="p-2 bg-gray-700 rounded flex justify-between items-center">
                    <span>${i + 1}: ${c.name}</span>
                    <button class="move-from-stack-btn bg-blue-600 hover:bg-blue-700 text-white text-xs px-2 py-1 rounded" data-stack-index="${i}">移動</button>
                </div>`).join('') || '<div>下にカードはありません。</div>';
        }

        stackedCardsList.addEventListener('click', (e) => {
            if (e.target.classList.contains('move-from-stack-btn')) {
                const stackIndex = e.target.dataset.stackIndex;
                const topCardId = stackViewModal.dataset.topCardId;
                moveMenu.dataset.stackSourceCardId = topCardId;
                moveMenu.dataset.stackIndex = stackIndex;
                const rect = e.target.getBoundingClientRect();
                moveMenu.style.display = 'block';
                moveMenu.style.left = `${rect.left - moveMenu.offsetWidth}px`;
                moveMenu.style.top = `${rect.top}px`;
            }
        });
        document.getElementById('close-stack-view').addEventListener('click', () => {
            stackViewModal.classList.add('hidden');
            delete stackViewModal.dataset.topCardId;
            hideAllMenus();
        });
        
        closeRevealModalBtn.addEventListener('click', () => {
            const remainingCards = revealedCards.filter(c => c !== null);
            if(remainingCards.length > 0) {
                if(revealSource === 'all') deck.push(...shuffleArray(remainingCards));
                else if(revealSource === 'bottom') deck.unshift(...remainingCards);
                else deck.push(...remainingCards.reverse()); // top
            }
            revealedCards = [];
            selectionOrder = [];
            updateDeckDisplay();
            revealModal.classList.add('hidden');
        });
        
        returnAllToBottomBtn.addEventListener('click', () => {
            selectionOrder.forEach(selectedIndex => {
                const cardData = revealedCards[selectedIndex];
                if (cardData) {
                    deck.unshift(cardData);
                    revealedCards[selectedIndex] = null;
                }
            });
            selectionOrder = [];
            updateDeckDisplay();
            refreshRevealModal();
        });

        function handleRevealSelection(index, cardElement) {
            const selectionIndex = selectionOrder.indexOf(index);
            if (selectionIndex > -1) {
                selectionOrder.splice(selectionIndex, 1);
            } else {
                selectionOrder.push(index);
            }
            updateRevealSelectionVisuals();
        }

        function updateRevealSelectionVisuals() {
            const cardElements = revealedCardsList.querySelectorAll('.card');
            cardElements.forEach((cardEl) => {
                const originalIndex = parseInt(cardEl.dataset.revealedIndex, 10);
                const selectionIndex = selectionOrder.indexOf(originalIndex);
                const badge = cardEl.querySelector('.selection-order-badge');
                if (selectionIndex > -1) {
                    cardEl.classList.add('selected');
                    badge.textContent = selectionIndex + 1;
                } else {
                    cardEl.classList.remove('selected');
                    if(badge) badge.textContent = '';
                }
            });
        }
        
        function refreshRevealModal() {
            revealedCardsList.innerHTML = '';
            revealedCards.forEach((cardData, index) => {
                if(cardData === null) return;
                const revealedCard = createCard(cardData, false, true);
                revealedCard.dataset.revealedIndex = index;
                revealedCard.draggable = false;
                
                const nameSpan = revealedCard.querySelector('.card-name');
                if(nameSpan) nameSpan.style.pointerEvents = 'none';

                revealedCard.addEventListener('click', (ev) => {
                    if (poisedCard.card) return;
                    ev.stopPropagation();
                    handleRevealSelection(index, revealedCard);
                });
                revealedCard.addEventListener('dblclick', (ev) => {
                    ev.stopPropagation();
                    showMoveMenu(revealedCard, ev.clientX, ev.clientY, { revealedIndex: index });
                });
                revealedCardsList.appendChild(revealedCard);
            });
            updateRevealSelectionVisuals();
        }

        function refreshYobunionModal() {
            yobunionCardsList.innerHTML = '';
            yobunionCards.forEach((cardData, index) => {
                if(cardData === null) return;
                const yobunionCard = createCard(cardData, false);
                yobunionCard.draggable = false;
                yobunionCard.addEventListener('dblclick', (ev) => {
                    ev.stopPropagation();
                    showMoveMenu(yobunionCard, ev.clientX, ev.clientY, { yobunionIndex: index });
                });
                yobunionCardsList.appendChild(yobunionCard);
            });
        }
        
        oneMoreYobunionBtn.addEventListener('click', () => {
            if (deck.length > 0) {
                yobunionCards.push(deck.pop());
                updateDeckDisplay();
                refreshYobunionModal();
            } else {
                alert('山札がありません。');
            }
        });

        finishYobunionBtn.addEventListener('click', () => {
            const remainingCards = yobunionCards.filter(c => c !== null);
            if(remainingCards.length > 0) {
                deck.unshift(...shuffleArray(remainingCards));
            }
            yobunionCards = [];
            updateDeckDisplay();
            yobunionModal.classList.add('hidden');
        });

        function hideNumberInputModal() {
            numberInputModal.classList.add('hidden');
            delete confirmNumberInputBtn.dataset.action;
            delete confirmNumberInputBtn.dataset.targetCardId;
        }

        cancelNumberInputBtn.addEventListener('click', hideNumberInputModal);

        confirmNumberInputBtn.addEventListener('click', () => {
            const num = parseInt(numberInputField.value, 10);
            const action = confirmNumberInputBtn.dataset.action;
            if (isNaN(num) || num <= 0) { hideNumberInputModal(); return; }
            
            const count = Math.min(num, deck.length);

            if (action === 'draw' && deck.length > 0) {
                for(let i=0; i < count; i++) {
                    document.getElementById('hand-zone').appendChild(createCard(deck.pop(), false));
                }
                updateDeckDisplay();
            } else if (action === 'reveal' && deck.length > 0) {
                revealedCards = deck.splice(deck.length - count, count);
                revealSource = 'top';
                updateDeckDisplay();
                selectionOrder = [];
                refreshRevealModal();
                revealModal.classList.remove('hidden');
            } else if (action === 'view-bottom' && deck.length > 0) {
                const bottomCount = Math.min(num, deck.length);
                revealedCards = deck.splice(0, bottomCount);
                revealSource = 'bottom';
                updateDeckDisplay();
                selectionOrder = [];
                refreshRevealModal();
                revealModal.classList.remove('hidden');
            } else if (action === 'mill' && deck.length > 0) {
                for(let i=0; i < count; i++) {
                    document.getElementById('graveyard-zone').appendChild(createCard(deck.pop(), false));
                }
                updateDeckDisplay();
            } else if (action === 'mana' && deck.length > 0) {
                const manaZone = document.getElementById('mana-zone');
                for(let i=0; i < count; i++) {
                    const cardData = deck.pop();
                    const newCard = createCard(cardData, false);
                    applyManaTap(newCard);
                    manaZone.appendChild(newCard);
                }
                updateDeckDisplay();
            } else if (action === 'shield' && deck.length > 0) {
                const shieldZone = document.getElementById('shield-zone');
                 for(let i=0; i < count; i++) {
                    const newCard = createCard(deck.pop(), true);
                    newCard.classList.add('tapped');
                    shieldZone.appendChild(newCard);
                }
                updateDeckDisplay();
            } else if (action === 'seal') {
                const card = document.getElementById(confirmNumberInputBtn.dataset.targetCardId);
                if (card && deck.length > 0) {
                    const numToSeal = Math.min(num, deck.length);
                    const currentSeals = JSON.parse(card.dataset.seals);
                    for (let i = 0; i < numToSeal; i++) {
                        currentSeals.push(deck.pop());
                    }
                    card.dataset.seals = JSON.stringify(currentSeals);
                    updateSealCount(card);
                    updateDeckDisplay();
                }
            } else if (action === 'remove-seals') {
                const card = document.getElementById(confirmNumberInputBtn.dataset.targetCardId);
                if (card) {
                    const currentSeals = JSON.parse(card.dataset.seals);
                    const numToRemove = Math.min(num, currentSeals.length);
                    const graveyard = document.getElementById('graveyard-zone');
                    for (let i = 0; i < numToRemove; i++) {
                        const sealData = currentSeals.pop();
                        graveyard.appendChild(createCard(sealData, false));
                    }
                    card.dataset.seals = JSON.stringify(currentSeals);
                    updateSealCount(card);
                }
            }
            hideNumberInputModal();
        });
        
        window.addEventListener('click', (e) => {
            const activeMenu = document.querySelector('.context-menu[style*="display: block"]');
            if (activeMenu && !activeMenu.contains(e.target) && !e.target.closest('.card') && !e.target.closest('.move-from-stack-btn')) {
                hideAllMenus();
            }
        });
        
        updateCardCount();
    </script>
</body>
</html>

